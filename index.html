<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Assembly Language Quiz</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        .quiz-container {
            max-width: 800px;
            margin: 2rem auto;
            padding: 2rem;
            background-color: #f9fafb;
            border-radius: 1rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
        }
        .option-btn {
            transition: background-color 0.3s, transform 0.2s;
        }
        .option-btn:hover {
            transform: translateY(-2px);
        }
        .correct {
            background-color: #d1fae5;
            border-color: #10b981;
        }
        .incorrect {
            background-color: #fee2e2;
            border-color: #ef4444;
        }
        .explanation {
            border-left-width: 4px;
        }
    </style>
</head>
<body class="bg-gray-100">

    <div class="quiz-container">
        <h1 class="text-3xl font-bold text-center text-gray-800 mb-6">Assembly Language Quiz</h1>
        
        <div id="quiz-area">
            <div class="flex justify-between items-center mb-4">
                <div id="question-counter" class="text-lg font-medium text-gray-600"></div>
                <div id="score-counter" class="text-lg font-medium text-gray-600"></div>
            </div>
            <div id="question-container" class="mb-6">
                <p id="question-text" class="text-xl text-gray-700"></p>
            </div>
            <div id="options-container" class="grid grid-cols-1 md:grid-cols-2 gap-4">
                <!-- Options will be dynamically inserted here -->
            </div>
            <div id="explanation-container" class="mt-6 hidden">
                <div id="explanation-box" class="p-4 rounded-lg explanation">
                    <p id="explanation-text" class="text-gray-800"></p>
                </div>
            </div>
            <div class="mt-8 text-center">
                <button id="next-btn" class="bg-blue-500 text-white px-8 py-3 rounded-lg font-semibold hover:bg-blue-600 transition duration-300 hidden">Next Question</button>
            </div>
        </div>

        <div id="result-area" class="hidden text-center">
            <h2 class="text-2xl font-bold text-gray-800 mb-4">Quiz Complete!</h2>
            <p id="final-score" class="text-xl text-gray-600 mb-6"></p>
            <button id="restart-btn" class="bg-green-500 text-white px-8 py-3 rounded-lg font-semibold hover:bg-green-600 transition duration-300">Restart Quiz</button>
        </div>
    </div>

    <script>
        const quizData = [
            {
                question: "What is the primary characteristic of machine language?",
                options: ["It uses symbolic names for operations.", "It is executed directly by the hardware.", "It is machine-independent.", "It is translated by an assembler."],
                correct: "It is executed directly by the hardware.",
                explanation: "Machine language is the native language of a processor, consisting of binary code (1s and 0s) that the hardware can execute directly without any translation."
            },
            {
                question: "What is the main function of an assembler?",
                options: ["To translate high-level language to machine code.", "To link multiple object files together.", "To convert assembly language into machine language.", "To debug assembly language programs."],
                correct: "To convert assembly language into machine language.",
                explanation: "An assembler is a program that translates source code written in assembly language into an object file containing the corresponding machine language instructions."
            },
            {
                question: "Which of the following is an advantage of high-level languages over assembly language?",
                options: ["Faster program execution", "Direct hardware access", "Program portability", "More compact code"],
                correct: "Program portability",
                explanation: "High-level language programs are generally portable because they contain few machine-dependent details and can be recompiled to run on different machines. Assembly language is machine-specific."
            },
            {
                question: "What are the two main fields of a machine language instruction?",
                options: ["Opcode and Operand", "Source and Destination", "Label and Mnemonic", "Instruction and Data"],
                correct: "Opcode and Operand",
                explanation: "A machine language instruction typically consists of an Opcode (operation code) that specifies the operation to be performed, and Operands that specify the data or memory locations to be used."
            },
            {
                question: "In the context of computer organization, what does the CPU consist of?",
                options: ["RAM and ROM", "Datapath and Control Unit", "Input and Output devices", "Address Bus and Data Bus"],
                correct: "Datapath and Control Unit",
                explanation: "The Central Processing Unit (CPU) is composed of the Datapath, which includes the ALU and registers, and the Control Unit (CU), which generates control signals to execute instructions."
            },
            {
                question: "What determines the physical address space of a computer?",
                options: ["The width of the data bus", "The speed of the clock", "The width of the address bus", "The size of the cache memory"],
                correct: "The width of the address bus",
                explanation: "The width of the address bus determines the number of unique memory locations that can be addressed. For an n-bit address bus, the physical address space is 2^n bytes."
            },
            {
                question: "What is the main difference between SRAM and DRAM?",
                options: ["SRAM is volatile, DRAM is not.", "SRAM is slower but denser than DRAM.", "SRAM is faster but less dense than DRAM.", "SRAM is used for main memory, DRAM for cache."],
                correct: "SRAM is faster but less dense than DRAM.",
                explanation: "SRAM (Static RAM) is faster and used for cache memory, but it's less dense and more expensive. DRAM (Dynamic RAM) is denser and cheaper, making it suitable for main memory, but it's slower and needs refreshing."
            },
            {
                question: "What is the purpose of cache memory?",
                options: ["To store the operating system.", "To act as permanent storage.", "To bridge the speed gap between the CPU and main memory.", "To manage I/O devices."],
                correct: "To bridge the speed gap between the CPU and main memory.",
                explanation: "Cache is a small, fast memory that stores frequently or recently used data and instructions to reduce the time the CPU has to wait for data from the slower main memory."
            },
            {
                question: "In the IA-32 architecture, which register is known as the primary accumulator?",
                options: ["EBX", "ECX", "EDX", "EAX"],
                correct: "EAX",
                explanation: "The EAX register is the primary accumulator. It is used in I/O operations and most arithmetic instructions, such as multiplication and division."
            },
            {
                question: "What is the purpose of the Instruction Pointer (IP) register?",
                options: ["To store the result of the last instruction.", "To point to the top of the stack.", "To store the offset address of the next instruction to be executed.", "To count loop iterations."],
                correct: "To store the offset address of the next instruction to be executed.",
                explanation: "The Instruction Pointer (IP), in conjunction with the Code Segment (CS) register, holds the full address of the next instruction that the CPU will execute."
            },
            {
                question: "Which flag in the control register indicates an overflow in signed arithmetic?",
                options: ["CF (Carry Flag)", "ZF (Zero Flag)", "SF (Sign Flag)", "OF (Overflow Flag)"],
                correct: "OF (Overflow Flag)",
                explanation: "The Overflow Flag (OF) is set when the result of a signed arithmetic operation is too large or too small to fit in the destination operand, indicating an overflow."
            },
            {
                question: "What does the `MOV` instruction do?",
                options: ["Performs a mathematical operation.", "Moves data from a source to a destination.", "Compares two operands.", "Jumps to a different part of the program."],
                correct: "Moves data from a source to a destination.",
                explanation: "The MOV instruction is used to copy data from a source operand (register, memory, or immediate value) to a destination operand (register or memory)."
            },
            {
                question: "Which assembly directive is used to declare initialized data?",
                options: ["`.bss` section", "`.text` section", "`.data` section", "`global` directive"],
                correct: "`.data` section",
                explanation: "The `.data` section is used to declare initialized data or constants that do not change at runtime, such as constant values, file names, or buffer sizes."
            },
            {
                question: "What is the purpose of the `bss` section in an assembly program?",
                options: ["To store the executable code.", "To declare initialized constants.", "To declare uninitialized variables.", "To define macros."],
                correct: "To declare uninitialized variables.",
                explanation: "The `.bss` section is a static memory section used for declaring variables or buffers for data that will be initialized later in the program. This memory is zero-filled."
            },
            {
                question: "In NASM, what character is used to start a comment?",
                options: ["#", "//", ";", "/*"],
                correct: ";",
                explanation: "In NASM (Netwide Assembler), comments begin with a semicolon (;). Anything after the semicolon on the same line is ignored by the assembler."
            },
            {
                question: "Which register is typically used as a loop counter?",
                options: ["AX", "BX", "CX", "DX"],
                correct: "CX",
                explanation: "The CX register is known as the count register. The ECX or CX register is used by the LOOP instruction to store the number of iterations."
            },
            {
                question: "What is the result of `XOR EAX, EAX`?",
                options: ["The value of EAX is doubled.", "The value of EAX is halved.", "The value of EAX is set to zero.", "The value of EAX is inverted."],
                correct: "The value of EAX is set to zero.",
                explanation: "The XOR operation sets a bit to 1 if the corresponding bits in the operands are different. XORing a register with itself results in all bits being cleared to 0, which is an efficient way to zero out a register."
            },
            {
                question: "What is the purpose of the `CMP` instruction?",
                options: ["To copy data between operands.", "To perform a logical comparison.", "To subtract one operand from another for comparison without storing the result.", "To jump to a specific label."],
                correct: "To subtract one operand from another for comparison without storing the result.",
                explanation: "The CMP instruction compares two operands by performing a subtraction. It does not store the result but sets the status flags (ZF, SF, CF, etc.) based on the outcome, which can then be used by conditional jump instructions."
            },
            {
                question: "Which instruction is used for an unconditional jump?",
                options: ["JE", "JNE", "JMP", "LOOP"],
                correct: "JMP",
                explanation: "The JMP (Jump) instruction is used for unconditional transfer of control. It immediately changes the flow of execution to the instruction at the specified label."
            },
            {
                question: "What is a key difference between a macro and a procedure (subroutine)?",
                options: ["Macros cannot have parameters.", "Procedures are expanded inline at assembly time.", "Macros are a text substitution mechanism expanded at assembly time.", "Procedures cannot call other procedures."],
                correct: "Macros are a text substitution mechanism expanded at assembly time.",
                explanation: "A macro is expanded by the assembler at each point it is called, inserting the macro's code directly. A procedure is a block of code that is called at runtime, involving a `CALL` and `RET` instruction, which adds some overhead but saves code space."
            },
            {
                question: "In the context of memory addressing, what is an 'offset'?",
                options: ["The starting address of a segment.", "A direct reference to a specific memory location.", "The number of address locations added to a base address.", "The total size of the memory."],
                correct: "The number of address locations added to a base address.",
                explanation: "An offset, or displacement, is a value added to a base address (often from a segment register) to calculate the final, absolute memory address of a piece of data."
            },
            {
                question: "Which addressing mode uses a constant value directly in the instruction?",
                options: ["Register addressing", "Immediate addressing", "Direct memory addressing", "Indirect memory addressing"],
                correct: "Immediate addressing",
                explanation: "In immediate addressing, the operand is a constant value or an expression that is part of the instruction itself, like `MOV EAX, 100`."
            },
            {
                question: "Which instruction is used to handle unsigned multiplication?",
                options: ["IMUL", "MUL", "DIV", "IDIV"],
                correct: "MUL",
                explanation: "The MUL instruction is used for multiplying unsigned binary data. The IMUL instruction is used for signed integer multiplication."
            },
            {
                question: "After a division operation with `DIV`, where is the quotient stored if the dividend was in the AX register?",
                options: ["In the AH register", "In the AL register", "In the DX register", "In the BX register"],
                correct: "In the AL register",
                explanation: "When performing an 8-bit division where the 16-bit dividend is in AX, the quotient is stored in the AL register and the remainder is stored in the AH register."
            },
            {
                question: "What is the purpose of the `TEST` instruction?",
                options: ["To perform a bitwise AND without changing the destination operand.", "To perform a bitwise OR and store the result.", "To reverse all the bits in an operand.", "To set a specific bit to 1."],
                correct: "To perform a bitwise AND without changing the destination operand.",
                explanation: "The TEST instruction performs a bitwise AND operation but only sets the flags (like ZF, SF, PF) according to the result. It does not modify the destination operand, making it useful for checking bit patterns."
            },
            {
                question: "Which flag determines the direction for string operations?",
                options: ["OF (Overflow Flag)", "DF (Direction Flag)", "IF (Interrupt Flag)", "CF (Carry Flag)"],
                correct: "DF (Direction Flag)",
                explanation: "The Direction Flag (DF) controls the direction of string operations like `MOVSB` or `CMPSB`. If DF is 0, the operation proceeds from left to right (increasing addresses). If DF is 1, it proceeds from right to left (decreasing addresses)."
            },
            {
                question: "What is the function of the `PUSH` instruction?",
                options: ["To retrieve an item from the stack.", "To enter an item onto the stack.", "To clear the stack.", "To jump to the stack segment."],
                correct: "To enter an item onto the stack.",
                explanation: "The PUSH instruction decrements the stack pointer (ESP) and then copies the operand to the new top of the stack."
            },
            {
                question: "What is direct recursion?",
                options: ["A procedure that calls another procedure.", "A procedure that calls itself.", "A procedure that never returns.", "A procedure that is called by the operating system."],
                correct: "A procedure that calls itself.",
                explanation: "Direct recursion occurs when a procedure contains a `CALL` instruction that refers to its own label, causing it to call itself."
            },
            {
                question: "For the Linux system call `sys_write`, which register holds the file descriptor?",
                options: ["EAX", "EBX", "ECX", "EDX"],
                correct: "EBX",
                explanation: "For Linux system calls via interrupt 80h, the arguments are passed in registers. For `sys_write`, EBX holds the file descriptor (e.g., 1 for stdout), ECX holds the pointer to the message, and EDX holds the message length."
            },
            {
                question: "What is the system call number for `sys_exit` in Linux (x86)?",
                options: ["1", "3", "4", "5"],
                correct: "1",
                explanation: "The system call number for `sys_exit` is 1. This number is placed in the EAX register before calling the kernel interrupt `int 0x80` to terminate the program."
            },
            {
                question: "What does the `AAA` instruction stand for?",
                options: ["ASCII Adjust After Addition", "Arithmetic Adjust Accumulator", "Advanced Arithmetic Addition", "ASCII Address Alignment"],
                correct: "ASCII Adjust After Addition",
                explanation: "The `AAA` instruction is used after adding two unpacked BCD digits (stored as ASCII characters) to adjust the result in the AL register back into a valid unpacked BCD format."
            },
            {
                question: "In packed BCD representation, how many decimal digits are stored in a single byte?",
                options: ["One", "Two", "Four", "Eight"],
                correct: "Two",
                explanation: "In packed BCD, each decimal digit is stored using four bits. Therefore, a single byte (8 bits) can store two decimal digits."
            },
            {
                question: "Which of the following is NOT a valid form for the `MOV` instruction?",
                options: ["MOV register, register", "MOV register, immediate", "MOV memory, memory", "MOV register, memory"],
                correct: "MOV memory, memory",
                explanation: "Most assembly instructions, including `MOV`, cannot have both the source and destination operands as memory locations. Data must first be moved into a register before it can be moved to another memory location."
            },
            {
                question: "What is the purpose of the `linker` program?",
                options: ["To edit source code.", "To convert source code to object code.", "To combine object files and libraries into an executable file.", "To trace the execution of a program."],
                correct: "To combine object files and libraries into an executable file.",
                explanation: "The linker takes one or more object files (produced by the assembler) and combines them with necessary code from link libraries to create a single, complete executable file."
            },
            {
                question: "The processor stores multi-byte data like `0725H` in memory in what sequence?",
                options: ["High-order byte first (big-endian)", "Low-order byte first (little-endian)", "It depends on the instruction used", "It is stored as a single unit"],
                correct: "Low-order byte first (little-endian)",
                explanation: "Intel processors use a reverse-byte sequence, also known as little-endian. The low-order byte (25H) is stored at the lower memory address, and the high-order byte (07H) is stored at the next higher address."
            },
            {
                question: "Which register pair gives the complete address of the current instruction?",
                options: ["DS:SI", "SS:SP", "CS:IP", "ES:DI"],
                correct: "CS:IP",
                explanation: "The Code Segment (CS) register holds the base address of the code segment, and the Instruction Pointer (IP) register holds the offset. Together, CS:IP points to the exact memory location of the instruction to be executed."
            },
            {
                question: "Which of these is NOT a valid data register?",
                options: ["AX", "BX", "CX", "FX"],
                correct: "FX",
                explanation: "The primary 32-bit data registers are EAX, EBX, ECX, and EDX. Their lower 16-bit halves are AX, BX, CX, and DX. FX is not a standard data register in the IA-32 architecture."
            },
            {
                question: "What is the purpose of the `EQU` directive?",
                options: ["To reserve uninitialized space.", "To define a constant value or expression.", "To start a procedure.", "To include an external file."],
                correct: "To define a constant value or expression.",
                explanation: "The `EQU` directive equates a symbol name to a constant value or expression. The assembler replaces every occurrence of the symbol with its defined value."
            },
            {
                question: "Which directive allows for multiple initializations to the same value?",
                options: ["DB", "DW", "TIMES", "RESB"],
                correct: "TIMES",
                explanation: "The `TIMES` directive is used to repeat an instruction or data definition a specified number of times. For example, `TIMES 10 DB 0` defines 10 bytes, each initialized to zero."
            },
            {
                question: "What is the function of the `DEC` instruction?",
                options: ["To divide an operand by two.", "To decrement an operand by one.", "To deallocate memory.", "To decode an instruction."],
                correct: "To decrement an operand by one.",
                explanation: "The `DEC` instruction decrements the value of its operand (register or memory location) by one."
            },
            {
                question: "Which instruction performs a bitwise logical OR operation?",
                options: ["AND", "OR", "XOR", "NOT"],
                correct: "OR",
                explanation: "The `OR` instruction performs a bitwise logical OR. The result bit is 1 if the bit in either or both operands is 1."
            },
            {
                question: "A conditional jump instruction like `JE` (Jump if Equal) typically follows which instruction?",
                options: ["MOV", "ADD", "CMP", "JMP"],
                correct: "CMP",
                explanation: "`JE` jumps if the Zero Flag (ZF) is set. The `CMP` instruction is used to compare two operands, and it sets the ZF if they are equal. Therefore, a `CMP` is used to set up the condition for a subsequent conditional jump."
            },
            {
                question: "What is the primary use of the Stack Segment (SS) register?",
                options: ["To store instruction codes.", "To store general data.", "To store the starting address of the stack.", "To store extra data segments."],
                correct: "To store the starting address of the stack.",
                explanation: "The Stack Segment (SS) register stores the starting address of the program's stack, which is used for storing return addresses, procedure parameters, and local variables."
            },
            {
                question: "Which system call is used to create a new file in Linux?",
                options: ["sys_open", "sys_creat", "sys_write", "sys_new"],
                correct: "sys_creat",
                explanation: "The `sys_creat()` system call (number 8) is used to create and open a new file. It returns a file descriptor in the EAX register."
            },
            {
                question: "What is the value for 'read-only' access mode when using the `sys_open` system call?",
                options: ["0", "1", "2", "3"],
                correct: "0",
                explanation: "When opening a file with `sys_open`, the access mode is passed in the ECX register. A value of 0 indicates read-only access, 1 is for write-only, and 2 is for read-write."
            },
            {
                question: "What does the `NOT` instruction do?",
                options: ["Clears an operand to zero.", "Sets an operand to all ones.", "Reverses or inverts the bits of an operand.", "Checks if an operand is zero."],
                correct: "Reverses or inverts the bits of an operand.",
                explanation: "The `NOT` instruction performs a bitwise logical NOT, which flips every bit in the operand (0 becomes 1, and 1 becomes 0). This is also known as the one's complement."
            },
            {
                question: "What is the purpose of a debugger?",
                options: ["To write code faster.", "To convert assembly to machine code.", "To trace program execution and view registers/memory.", "To link object files."],
                correct: "To trace program execution and view registers/memory.",
                explanation: "A debugger is a crucial tool that allows a programmer to step through a program one instruction at a time, inspect the contents of registers and memory, and set breakpoints to find and fix errors."
            },
            {
                question: "In a memory hierarchy, which storage is the fastest?",
                options: ["Registers", "L1 Cache", "Main Memory (DRAM)", "Magnetic Disk"],
                correct: "Registers",
                explanation: "Registers are at the top of the memory hierarchy. They are located inside the CPU itself, providing the fastest possible access to data."
            },
            {
                question: "What does 'portability' mean in the context of programming languages?",
                options: ["The code can be written on a laptop.", "The code can run on different types of machines with little or no modification.", "The code is easy to read and understand.", "The code executes very quickly."],
                correct: "The code can run on different types of machines with little or no modification.",
                explanation: "Portability is the ability of a program to be compiled and run on different computer architectures and operating systems. High-level languages are generally portable, while assembly language is not."
            }
        ];

        const quizArea = document.getElementById('quiz-area');
        const resultArea = document.getElementById('result-area');
        const questionCounter = document.getElementById('question-counter');
        const scoreCounter = document.getElementById('score-counter');
        const questionText = document.getElementById('question-text');
        const optionsContainer = document.getElementById('options-container');
        const explanationContainer = document.getElementById('explanation-container');
        const explanationBox = document.getElementById('explanation-box');
        const explanationText = document.getElementById('explanation-text');
        const nextBtn = document.getElementById('next-btn');
        const restartBtn = document.getElementById('restart-btn');
        const finalScore = document.getElementById('final-score');

        let currentQuestionIndex = 0;
        let score = 0;

        function startQuiz() {
            currentQuestionIndex = 0;
            score = 0;
            quizArea.classList.remove('hidden');
            resultArea.classList.add('hidden');
            nextBtn.classList.add('hidden');
            showQuestion();
        }

        function showQuestion() {
            resetState();
            const currentQuestion = quizData[currentQuestionIndex];
            questionText.innerText = currentQuestion.question;
            questionCounter.innerText = `Question ${currentQuestionIndex + 1} / ${quizData.length}`;
            scoreCounter.innerText = `Score: ${score}`;

            currentQuestion.options.forEach(option => {
                const button = document.createElement('button');
                button.innerText = option;
                button.classList.add('option-btn', 'w-full', 'p-4', 'text-left', 'bg-white', 'border', 'border-gray-300', 'rounded-lg', 'hover:bg-gray-50');
                button.addEventListener('click', selectAnswer);
                optionsContainer.appendChild(button);
            });
        }

        function resetState() {
            while (optionsContainer.firstChild) {
                optionsContainer.removeChild(optionsContainer.firstChild);
            }
            explanationContainer.classList.add('hidden');
            nextBtn.classList.add('hidden');
        }

        function selectAnswer(e) {
            const selectedBtn = e.target;
            const correct = selectedBtn.innerText === quizData[currentQuestionIndex].correct;

            if (correct) {
                score++;
                selectedBtn.classList.add('correct');
                explanationBox.className = 'p-4 rounded-lg explanation border-green-500 bg-green-50';
            } else {
                selectedBtn.classList.add('incorrect');
                explanationBox.className = 'p-4 rounded-lg explanation border-red-500 bg-red-50';
            }
            
            explanationText.innerText = quizData[currentQuestionIndex].explanation;
            explanationContainer.classList.remove('hidden');

            Array.from(optionsContainer.children).forEach(button => {
                if (button.innerText === quizData[currentQuestionIndex].correct) {
                    if(!correct) button.classList.add('correct');
                }
                button.disabled = true;
            });

            if (quizData.length > currentQuestionIndex + 1) {
                nextBtn.classList.remove('hidden');
            } else {
                showResult();
            }
        }
        
        function showResult() {
            quizArea.classList.add('hidden');
            resultArea.classList.remove('hidden');
            finalScore.innerText = `Your final score is ${score} out of ${quizData.length}.`;
        }

        nextBtn.addEventListener('click', () => {
            currentQuestionIndex++;
            showQuestion();
        });

        restartBtn.addEventListener('click', startQuiz);

        startQuiz();
    </script>
</body>
</html>
